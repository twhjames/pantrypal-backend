from datetime import datetime
from typing import List, Optional

from pydantic import BaseModel, Field, field_validator, model_validator

from src.core.chatbot.constants import ChatbotMessageRole
from src.core.chatbot.specs import ChatMessageSpec
from src.core.common.utils import DateTimeUtils


class Message(BaseModel):
    user_id: int = Field(
        ..., description="Unique identifier of the user sending the message"
    )
    role: ChatbotMessageRole = Field(
        ...,
        example=ChatbotMessageRole.USER,
        description="Role in the conversation (user, assistant, or system)",
    )
    content: str = Field(
        ...,
        example="I have some rice and eggs. What can I cook?",
        description="Message content",
    )
    timestamp: Optional[datetime] = None

    @field_validator("role", mode="before")
    @classmethod
    def validate_and_normalize_role(cls, value):
        if isinstance(value, ChatbotMessageRole):
            return value
        try:
            return ChatbotMessageRole(value.lower())
        except ValueError:
            raise ValueError(
                f"Invalid role: {value}. Must be one of: "
                f"{', '.join([e.value for e in ChatbotMessageRole])}"
            )

    @model_validator(mode="after")
    def set_timestamp_if_missing(self):
        if self.timestamp is None:
            self.timestamp = DateTimeUtils.get_utc_now()
        return self

    def to_spec(self) -> ChatMessageSpec:
        return ChatMessageSpec(
            user_id=self.user_id,
            role=self.role,
            content=self.content,
            timestamp=self.timestamp or DateTimeUtils.get_utc_now(),
        )


class Messages(BaseModel):
    messages: List[Message] = Field(
        ..., description="List of messages to simulate the conversation"
    )


class ChatReply(BaseModel):
    reply: str = Field(
        ...,
        example="How about making egg fried rice with some soy sauce and vegetables?",
        description="Response generated by the chatbot",
    )
